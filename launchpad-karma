#!/usr/bin/env python3
#
# Author: Alberto Donato <alberto.donato@gmail.com>
#
# This file is part of launchpad-karma.
#
# launchpad-karma is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# launchpad-karma is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with launchpad-karma.  If not, see
# <http://www.gnu.org/licenses/>.

import sys
import os
from itertools import chain
from tempfile import mkdtemp
from datetime import datetime, timedelta
from shutil import copy, rmtree
from argparse import ArgumentParser
from configparser import ConfigParser
import json

from sqlite3 import connect, PARSE_DECLTYPES
from jinja2 import Environment, FileSystemLoader
from launchpadlib.launchpad import Launchpad
from launchpadlib.uris import LPNET_SERVICE_ROOT

NAME = 'launchpad-karma'

# The dir in which this file is located
DIR = os.path.dirname(__file__)
# Configuration file
CONFIG_FILE = os.path.join(DIR, '{}.ini'.format(NAME))
# Database file
DB_FILE = os.path.join(DIR, 'karma.sqlite')
# CSS file for HTML page
CSS_FILE = os.path.join(DIR, 'style.css')


class MissingConfig(Exception):
    '''Missing configuration option.'''


class NotConnected(Exception):
    '''Not connected to the database'''


class Database:
    '''SQLite3 database wrapper.'''

    def __init__(self, filename):
        self._filename = filename
        self._conn = None
        self._cur = None

    def connect(self):
        '''Connect to the database.'''
        must_create = not os.path.exists(self._filename)
        self._conn = connect(self._filename, detect_types=PARSE_DECLTYPES)
        self._cur = self._conn.cursor()
        if must_create:
            self._create()

    def add_karma(self, date, value):
        '''Add value for the specified date.'''
        self._execute(
            'INSERT INTO karma (date, value) VALUES (?, ?)', [date, value])

    def get_karma(self, start=None, end=None):
        '''Return karma, optionally for the specify date range.'''
        query = 'SELECT date, value FROM karma'
        args = []
        if start:
            query += ' WHERE date >= ?'
            args.append(start)
        if end:
            if start:
                query += ' AND'
            query += ' date <= ?'
            args.append(end)
        query += ' ORDER BY date ASC'
        return self._execute(query, args)

    def close(self):
        '''Close db connection.'''
        if not self._conn:
            raise NotConnected()
        self._conn.close()
        self._conn = None
        self._cur = None

    def _create(self):
        '''Create database tables.'''
        self._execute(
            'CREATE TABLE karma ('
            '  date DATE NOT NULL,'
            '  value INTEGER NOT NULL)')

    def _execute(self, statement, args=None):
        '''Execute a query'''
        if not self._conn:
            raise NotConnected()

        with self._conn:
            if args is None:
                self._cur.execute(statement)
            else:
                self._cur.execute(statement, args)
            return self._cur.fetchall()


def log(message):
    '''Log a message to stderr.'''
    sys.stderr.write(message + '\n')


def get_user_karma(user):
    '''Return the karma for a user.'''
    tempdir = mkdtemp(prefix='{}-'.format(NAME))
    lp = Launchpad.login_anonymously(
        NAME, service_root=LPNET_SERVICE_ROOT,
        launchpadlib_dir=tempdir)
    karma = lp.people[user].karma
    rmtree(tempdir, ignore_errors=True)
    return karma


def today():
    '''Return the current date as a 'YYYY-MM-DD' string.'''
    return datetime.utcnow().date().isoformat()


def get_month_ranges(months):
    '''Return date ranges for the specified of months back.'''
    ranges = []
    end = datetime.utcnow().date()
    start = end.replace(day=1)
    ranges.append((start, end))

    for x in range(months - 1):
        end = start - timedelta(days=1)
        start = end.replace(day=1)
        ranges.append((start, end))

    return ranges


def get_graph_data(db, months):
    '''Return data for graphs.'''
    graphs = []
    for start, end in get_month_ranges(months):
        values = db.get_karma(start=start, end=end)
        if not values:
            continue
        x, y = zip(*((x.day, y) for x, y in values))

        month_of_year = '{:04d}-{:02d}'.format(start.year, start.month)
        log('Collected data for {}'.format(month_of_year))
        graphs.append(
            {'id': 'graph-{}'.format(month_of_year),
             'label': start.strftime('%B %Y'),
             'x': x,
             'y': y})
    return graphs


def get_graph_steps(graphs, step_width=100):
    '''Return graph steps based on values from all graphs.'''
    min_y = min(chain(*(graph['y'] for graph in graphs)))
    max_y = max(chain(*(graph['y'] for graph in graphs)))
    min_value = int(min_y / step_width) * step_width
    max_value = int(max_y / step_width) * step_width + step_width
    num_steps = int((max_value - min_value) / step_width)
    if (max_value - min_value) % step_width:
        num_steps + 1
    return min_value, num_steps, step_width


def generate_page(user, target_dir, graphs, graph_steps, local=False):
    '''Generate the HTML page for graphs.'''
    if not os.path.isdir(target_dir):
        os.makedirs(target_dir)

    environment = Environment(loader=FileSystemLoader(DIR))
    environment.filters['json'] = json.dumps
    html_template = environment.get_template('template.html')
    js_template = environment.get_template('template.js')

    context = {
        'user': user,
        'resource_proto': 'https:' if local else '',
        'graph_config': {
            'scale_start_value': graph_steps[0],
            'scale_steps': graph_steps[1],
            'scale_step_width': graph_steps[2]},
        'graphs': graphs}
    log('Rendering HTML template')
    with open(os.path.join(target_dir, 'index.html'), 'w') as fd:
        fd.write(html_template.render(context))
    log('Rendering JS template')
    with open(os.path.join(target_dir, 'plot.js'), 'w') as fd:
        fd.write(js_template.render(context))
    copy(CSS_FILE, target_dir)


def get_parser():
    '''Return a command line parser'''
    parser = ArgumentParser(
        description='Collect and graph user karma from Launchpad.')
    parser.add_argument(
        '--no-update', action='store_true',
        help='don\'t update karma database')
    parser.add_argument(
        '--no-generate', action='store_true',
        help='don\'t generate graphs')
    parser.add_argument(
        '--local', action='store_true',
        help=('Set protocol for web resources so that generated page can '
              'be viewed locally.'))
    return parser


def get_config():
    '''Return configuration options.'''
    defaults = {
        'months': 12,
        'target-dir': 'output'}
    parser = ConfigParser(defaults=defaults)
    parser.read(CONFIG_FILE)
    config = parser.defaults()
    config['months'] = int(config['months'])
    if 'user' not in config:
        raise MissingConfig('Key "user" must be present in config')
    return config


def main():
    args = get_parser().parse_args()
    config = get_config()

    log('Accessing SQLite database {}'.format(DB_FILE))
    db = Database(DB_FILE)
    db.connect()

    if not args.no_update:
        date = today()
        karma = get_user_karma(config['user'])
        db.add_karma(date, karma)
        log(
            'Karma for user {} on {} is {}'.format(
                config['user'], date, karma))

    if not args.no_generate:
        graphs = get_graph_data(db, config['months'])
        graph_steps = get_graph_steps(graphs)
        generate_page(
            config['user'], config['target-dir'], graphs, graph_steps,
            local=args.local)

    db.close()


if __name__ == '__main__':
    main()
